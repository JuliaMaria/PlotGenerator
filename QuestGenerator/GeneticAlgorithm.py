# TODO Evolve quests generated by planner to match desired story arc
import itertools

import numpy as np
from tqdm import tqdm

# TODO Take domain database constraints into account


class GeneticAlgorithm:
    def __init__(self, domain_database, population_size=100, mutation_prob=0.2, elitism_factor=0.2, start_size=(1, 31), goal_size=(1, 11)):
        self.population_size = population_size
        self.start_size = start_size
        self.goal_size = goal_size
        self.mutation_prob = mutation_prob
        self.elitism_factor = elitism_factor

        self.dd = domain_database

    def generate_random_individual(self):
        # Choose how many objects to start with
        objects_start_size = np.random.randint(self.start_size[0], self.start_size[1])

        # Choose how many objects of different types to choose
        object_types_start_size = np.random.default_rng().multinomial(objects_start_size, [1 / len(self.dd.objects)] * len(self.dd.objects), size=1)[0]

        # Choose how many relations to start with
        max_relations_start_size = self.start_size[1]-objects_start_size if self.start_size[1]-objects_start_size > self.start_size[0] + 1 else self.start_size[0] + 1
        relations_start_size = np.random.randint(self.start_size[0], max_relations_start_size)

        # Choose how many relations to end with
        goal_size = np.random.randint(self.goal_size[0], self.goal_size[1])

        # Choose objects of the plot
        objects = {
            object_type: np.random.choice(self.dd.objects[object_type], object_type_size)
            for object_type, object_type_size in zip(self.dd.objects.keys(), object_types_start_size)
        }
        all_objects = list(np.concatenate(list(objects.values())))

        # Filter valid relations for objects of the plot
        relations = [relation for relation in self.dd.relations if set(relation["values"]).issubset(all_objects)]

        # Choose start relations of the plot
        start_relations = list(np.random.choice(relations, relations_start_size)) if relations else []

        # Filter valid predicates for objects of the plot
        predicates = [
            predicate
            for predicate in self.dd.predicates
            if np.all([len(objects[parameter["type"]]) for parameter in predicate["parameters"]])
        ]
        # Choose goal relations of the plot
        goal_predicates = list(np.random.choice(predicates, goal_size)) if predicates else []
        goal_relations = [
            self.dd.relation_representation(predicate["name"], [np.random.choice(objects[parameter["type"]]) for parameter in predicate["parameters"]])
            for predicate in goal_predicates
        ]

        objects = [self.dd.object_representation(object_type, object) for object_type, objects_ in objects.items() for object in objects_]

        individual = [objects + start_relations, goal_relations]

        return individual

    def generate_initial_population(self):
        population = []
        for i in tqdm(range(self.population_size)):
            individual = self.generate_random_individual()
            population.append(individual)
        return population

    def perform_planning(self, individual):
        pddl_individual = self.convert_indivdual_to_pddl_format(individual)
        actions_plan = []  # TODO Run HSP planner
        return actions_plan

    def convert_indivdual_to_pddl_format(self, individual, name="converted_ind"):
        # returns the resulting pddl filename
        filename = name + '.txt'

        with open(filename, 'w') as f:
            f.write(f"(define (problem {name})")
            f.write(f"\n\t(:domain {self.dd.name})")

        # objects
        objects = [p for p in individual[0] if 'type' in p.keys()]
        objects = list({v['name']: v for v in objects}.values())

        with open(filename, 'a') as f:
            f.write("\n\t(:objects")

            for o in objects:
                f.write(f"\n\t\t({o['name']} - {o['type']})")

            f.write("\n\t)")

        # preconditions
        preconditions = [p for p in individual[0] if 'values' in p.keys()]
        preconditions = list({v['name']: v for v in preconditions}.values())

        with open(filename, 'a') as f:
            f.write("\n\t(:init")

            for precondition in preconditions:
                f.write(f"\n\t\t({precondition['name']}")
                for v in precondition['values']:
                    f.write(f" {v}")
                f.write(")")

            f.write("\n\t)")

        # effects
        effects = individual[1]
        effects = list({v['name']: v for v in effects}.values())

        with open(filename, 'a') as f:
            f.write("\n\t(:goal")
            f.write("\n\t\t(and")

            for effect in effects:
                f.write(f"\n\t\t\t({effect['name']}")
                for v in effect['values']:
                    f.write(f" {v}")
                f.write(")")

            f.write("\n\t\t)")
            f.write("\n\t)")

            f.write("\n)")

        return filename

    def evaluate_individual(self, individual, desired_story_arc):
        # TODO Evaluate individual as described in the paper
        #  using HSP planner to generate actions for given start and goal
        #  and calculate fitness according to event effects from domain database
        actions_plan = self.perform_planning(individual)
        actions = []  # TODO Extract actions from plan
        tension_arc = [self.dd.event_effects[action] for action in actions]
        # TODO Calculate loss between two story arcs
        return 0

    def evaluate_population(self, population, desired_story_arc):
        evaluated_population = []
        for individual in population:
            evaluated_population.append(
                {
                    "individual": individual,
                    "fitness": self.evaluate_individual(individual, desired_story_arc)
                }
            )
        return evaluated_population

    def perform_crossover(self, selected_individuals):
        # Select pairs of individuals for reproduction at random
        all_pairs = list(itertools.combinations_with_replacement(selected_individuals, 2))
        # Each pair produces two children so we take self.population_size//2 pairs
        pairs_to_reproduce_idxs = np.random.choice(len(all_pairs), self.population_size//2, replace=False)
        pairs_to_reproduce = [all_pairs[idx] for idx in pairs_to_reproduce_idxs]

        new_population = []

        for individual_1, individual_2 in pairs_to_reproduce:
            # Select split points for start and goal according to length of shortest parent
            individual_1 = individual_1["individual"]
            individual_2 = individual_2["individual"]
            smallest_individual_start_length = min(len(individual_1[0]), len(individual_2[0]))
            smallest_individual_goal_length = min(len(individual_1[1]), len(individual_2[1]))
            start_split_point = np.random.randint(0, smallest_individual_start_length - 1) if smallest_individual_start_length - 1 > 0 else 0
            goal_split_point = np.random.randint(0, smallest_individual_goal_length - 1) if smallest_individual_goal_length - 1 > 0 else 0

            # Generate offspring
            child_1 = [
                individual_1[0][:start_split_point] + individual_2[0][start_split_point:],
                individual_1[1][:goal_split_point] + individual_2[1][goal_split_point:]
            ]

            child_2 = [
                individual_2[0][:start_split_point] + individual_1[0][start_split_point:],
                individual_2[1][:goal_split_point] + individual_1[1][goal_split_point:]
            ]

            new_population.append(child_1)
            new_population.append(child_2)

        return new_population

    def add_literal_to_individual(self, individual, target):
        # TODO Add random literal to individual
        # Target: 0 - start, 1 - goal, 2 - both
        return individual

    def remove_literal_from_individual(self, individual, target):
        # TODO Remove random literal from individual
        # Target: 0 - start, 1 - goal, 2 - both
        return individual

    def perform_mutation(self, population):
        new_population = []

        for individual in population:
            if np.random.rand() < self.mutation_prob:
                # Start, goal or both
                mutation_target = np.random.choice(3)
                # Add, remove or both
                mutation_type = np.random.choice(3)

                if mutation_type in [0, 2]:
                    individual = self.add_literal_to_individual(individual, mutation_target)
                if mutation_type in [1, 2]:
                    individual = self.remove_literal_from_individual(individual, mutation_target)

            new_population.append(individual)

        return new_population

    def select_best_individuals(self):
        elite_individuals_to_copy = int(self.elitism_factor*self.population_size)
        sorted_individuals = sorted(self.population, key=lambda x: x["fitness"], reverse=True)

        elite_individuals = sorted_individuals[:elite_individuals_to_copy]
        remaining_individuals = sorted_individuals[elite_individuals_to_copy:]

        max_sum = sum([individual["fitness"] for individual in remaining_individuals])
        if max_sum != 0:
            selection_probs = [individual["fitness"] / max_sum for individual in remaining_individuals]
        else:
            selection_probs = [1 / len(remaining_individuals) for individual in remaining_individuals]

        chosen_remaining_individuals = [
            remaining_individuals[idx]
            for idx in np.random.choice(len(remaining_individuals), p=selection_probs, size=self.population_size-elite_individuals_to_copy)
        ]

        return elite_individuals + chosen_remaining_individuals

    def __call__(self, generations, num_quests, desired_story_arc):
        quests = []

        for quest in range(num_quests):
            population = self.generate_initial_population()
            self.population = self.evaluate_population(population, desired_story_arc)

            for generation in range(generations):
                best_individuals = self.select_best_individuals()
                population = self.perform_crossover(best_individuals)
                population = self.perform_mutation(population)
                self.population = self.evaluate_population(population, desired_story_arc)

            best_quest = max(self.population, key=lambda x: x["fitness"])
            quests.append(best_quest["individual"])

            # TODO Update domain database with new quest

        quests_with_plans = [(quest, self.perform_planning(quest)) for quest in quests]

        return quests_with_plans
