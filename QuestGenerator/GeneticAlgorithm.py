# Evolve quests generated by planner to match desired story arc

import numpy as np
from tqdm import tqdm

from PlotGenerator.DomainDatabase.DomainDatabase import DomainDatabase

# TODO Take constraints into account


class GeneticAlgorithm:
    def __init__(self, population_size=100, start_size=(1, 31), goal_size=(1, 11), domain_path="PlotGenerator/Domain/World.xml"):
        self.population_size = population_size
        self.start_size = start_size
        self.goal_size = goal_size

        self.dd = DomainDatabase(domain_path)

        self.population = self.generate_initial_population()

    def generate_random_individual(self):
        # Choose how many objects to start with
        objects_start_size = np.random.randint(self.start_size[0], self.start_size[1])

        # Choose how many objects of different types to choose
        object_types_start_size = np.random.default_rng().multinomial(objects_start_size, [1 / len(self.dd.objects)] * len(self.dd.objects), size=1)[0]

        # Choose how many relations to start with
        max_relations_start_size = self.start_size[1]-objects_start_size if self.start_size[1]-objects_start_size > self.start_size[0] + 1 else self.start_size[0] + 1
        relations_start_size = np.random.randint(self.start_size[0], max_relations_start_size)

        # Choose how many relations to end with
        goal_size = np.random.randint(self.goal_size[0], self.goal_size[1])

        # Choose objects of the plot
        objects = {
            object_type: np.random.choice(self.dd.objects[object_type], object_type_size)
            for object_type, object_type_size in zip(self.dd.objects.keys(), object_types_start_size)
        }
        all_objects = list(np.concatenate(list(objects.values())))

        # Filter valid relations for objects of the plot
        relations = [relation for relation in self.dd.relations if set(relation["values"]).issubset(all_objects)]

        # Choose start relations of the plot
        start_relations = list(np.random.choice(relations, relations_start_size)) if relations else []

        # Filter valid predicates for objects of the plot
        predicates = [
            predicate
            for predicate in self.dd.predicates
            if np.all([len(objects[parameter["type"]]) for parameter in predicate["parameters"]])
        ]
        # Choose goal relations of the plot
        goal_predicates = list(np.random.choice(predicates, goal_size)) if predicates else []
        goal_relations = [
            self.dd.relation_representation(predicate["name"], [np.random.choice(objects[parameter["type"]]) for parameter in predicate["parameters"]])
            for predicate in goal_predicates
        ]

        objects = [self.dd.object_representation(object_type, object) for object_type, objects_ in objects.items() for object in objects_]

        individual = [objects + start_relations, goal_relations]

        return individual

    def generate_initial_population(self):
        population = []
        for i in tqdm(range(self.population_size)):
            individual = self.generate_random_individual()
            population.append(individual)
        return population

    def evaluate_individual(self, individual):
        return 0


ga = GeneticAlgorithm()
print(ga.population)
